# ABP Agent v3.1.0 Release Notes

**Release Date:** October 25, 2025
**Priority:** Critical - Production Bug Fixes
**Status:** Ready for Deployment

---

## Executive Summary

This release fixes a **critical production bug** that would cause the agent endpoints to crash with `NameError`, and implements **5 missing backend endpoints** required for the frontend Settings and Account Management UI.

### Critical Bugs Fixed
- ‚úÖ Fixed `NameError` crash in `/agent/query` and `/agent/approve` endpoints
- ‚úÖ Fixed stateful/stateless conflict preventing Human-in-the-Loop workflows
- ‚úÖ Implemented persistent checkpointing for proper approval flows

### New Features
- ‚úÖ 5 new API endpoints for Settings and Account Management
- ‚úÖ Enhanced database schema with account status tracking
- ‚úÖ OAuth account management (list, add, remove)

---

## Table of Contents

1. [Critical Bug Fixes](#critical-bug-fixes)
2. [New API Endpoints](#new-api-endpoints)
3. [Database Schema Changes](#database-schema-changes)
4. [Breaking Changes](#breaking-changes)
5. [Migration Guide](#migration-guide)
6. [Testing Checklist](#testing-checklist)
7. [Deployment Instructions](#deployment-instructions)

---

## Critical Bug Fixes

### Issue #1: Agent Endpoints Crash (NameError)

**Severity:** üî¥ Critical - Application Breaking
**Affected Endpoints:** `/agent/query`, `/agent/approve`

#### Problem Description
The endpoints `/agent/query` and `/agent/approve` would fail immediately with:
```
NameError: name 'graph' is not defined
```

**Root Cause:**
- The variable `graph` was never initialized in these endpoint handlers
- The global `agent_graph` variable in `graph_refactored.py` was always `None`
- Only `/agent/invoke` correctly called `initialize_graph(session)`

#### Solution Implemented

**File: `src/main_refactored.py`**

```python
# BEFORE (Broken):
@app.post("/agent/query")
async def agent_query(...):
    # ... setup code ...
    final_state = graph.invoke(...)  # ‚ùå NameError!

# AFTER (Fixed):
@app.post("/agent/query")
async def agent_query(...):
    graph = await initialize_graph(session)  # ‚úÖ Initialize first
    final_state = await graph.ainvoke(...)   # ‚úÖ Use async invoke
```

**Changes:**
- Line 243: Added `graph = await initialize_graph(session)` to `/agent/query`
- Line 351: Added `graph = await initialize_graph(session)` to `/agent/approve`
- Line 409: Updated `/agent/invoke` to use `await initialize_graph(session)`
- All endpoints now use `await graph.ainvoke()` instead of `graph.invoke()`

---

### Issue #2: Stateless vs Stateful Conflict

**Severity:** üî¥ Critical - Human-in-the-Loop Broken
**Affected Workflow:** Approval-based rescheduling

#### Problem Description
Even with the graph initialized, the Human-in-the-Loop workflow would fail:

1. User calls `/agent/query` ‚Üí Agent pauses for approval
2. Graph saves checkpoint to **MemorySaver A** (in-memory)
3. Graph instance is destroyed, MemorySaver A garbage collected
4. User calls `/agent/approve` ‚Üí New graph instance created
5. New graph has **MemorySaver B** (fresh, empty)
6. ‚ùå **Checkpoint not found** - Cannot resume workflow

**Root Cause:**
- `MemorySaver` creates in-memory storage per graph instance
- Checkpoints don't persist across HTTP requests
- Each endpoint call created a new graph with empty memory

#### Solution Implemented

**File: `src/graph/graph_refactored.py`**

**BEFORE:**
```python
from langgraph.checkpoint.memory import MemorySaver

def create_agent_graph(session):
    # ... workflow setup ...
    memory = MemorySaver()  # ‚ùå New memory per call
    app = workflow.compile(checkpointer=memory, ...)
    return app
```

**AFTER:**
```python
from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver

# Module-level persistent checkpointer
_checkpointer = None

async def get_checkpointer():
    global _checkpointer
    if _checkpointer is None:
        _checkpointer = AsyncSqliteSaver.from_conn_string("checkpoints.db")
    return _checkpointer

async def create_agent_graph(session):
    # ... workflow setup ...
    checkpointer = await get_checkpointer()  # ‚úÖ Shared persistent storage
    app = workflow.compile(checkpointer=checkpointer, ...)
    return app
```

**How It Works Now:**
1. `/agent/query` saves checkpoint ‚Üí `checkpoints.db` file
2. Graph instance destroyed, but checkpoint persists on disk
3. `/agent/approve` creates new graph with **same checkpointer**
4. ‚úÖ **Checkpoint loaded** from `checkpoints.db` - Workflow resumes!

**Changes:**
- Lines 5-29: Replaced MemorySaver with AsyncSqliteSaver
- Created singleton `get_checkpointer()` function
- Made `create_agent_graph()` and `initialize_graph()` async
- All graph instances now share the same persistent checkpoint storage

**Benefits:**
- ‚úÖ Checkpoints survive server restarts
- ‚úÖ Human-in-the-Loop workflows work correctly
- ‚úÖ Multiple concurrent users supported (via thread_id isolation)
- ‚úÖ Can inspect checkpoint state for debugging

---

## New API Endpoints

### 1. GET /api/v1/settings

**Purpose:** Get user's scheduling rules and preferences (constitution)

**Authentication:** JWT Bearer token required

**Request:**
```http
GET /api/v1/settings
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "user_id": "uuid",
  "work_hours": {
    "start": "09:00",
    "end": "17:00",
    "timezone": "America/Los_Angeles"
  },
  "protected_time_blocks": [
    {
      "id": "ptb-1",
      "name": "Kids School Run",
      "day_of_week": "weekdays",
      "start_time": "15:00",
      "end_time": "16:00",
      "recurring": true
    }
  ],
  "scheduling_rules": {
    "no_weekend_meetings": true,
    "busyness_threshold": 0.85,
    "lookahead_days": 14
  }
}
```

**Implementation:** `src/main_refactored.py:516-583`

**Notes:**
- Returns default constitution if user hasn't customized settings
- Reads from `scheduling_rules` table
- Uses authenticated user from JWT token

---

### 2. POST /api/v1/settings

**Purpose:** Update user's scheduling rules (supports partial updates)

**Authentication:** JWT Bearer token required

**Request:**
```http
POST /api/v1/settings
Authorization: Bearer <token>
Content-Type: application/json

{
  "work_hours": {
    "start": "08:00",
    "end": "18:00"
  },
  "scheduling_rules": {
    "busyness_threshold": 0.90
  }
}
```

**Response (200 OK):**
```json
{
  "message": "Settings updated successfully",
  "updated_at": "2025-10-25T15:30:00Z"
}
```

**Implementation:** `src/main_refactored.py:586-682`

**Notes:**
- Only updates provided fields (partial update)
- Creates/updates records in `scheduling_rules` table
- Rule types: WORK_HOURS, PROTECTED_TIME, GENERAL

---

### 3. GET /api/v1/auth/google/url

**Purpose:** Generate OAuth URL for connecting Google Calendar

**Authentication:** JWT Bearer token required

**Request:**
```http
GET /api/v1/auth/google/url
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "auth_url": "https://accounts.google.com/o/oauth2/v2/auth?client_id=...&state=<user_id>&..."
}
```

**Implementation:** `src/main_refactored.py:687-706`

**Notes:**
- State parameter contains user_id for callback verification
- Scopes: calendar, calendar.events
- Redirect URI points to existing `/auth/callback` endpoint

**Usage Flow:**
1. Frontend calls this endpoint
2. Frontend redirects user to `auth_url`
3. User authorizes on Google
4. Google redirects to `/auth/callback` with code
5. Backend saves credentials to database

---

### 4. GET /api/v1/auth/accounts

**Purpose:** List all connected Google Calendar accounts

**Authentication:** JWT Bearer token required

**Request:**
```http
GET /api/v1/auth/accounts
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "accounts": [
    {
      "account_id": "token-uuid-1",
      "email": "user@company.com",
      "is_primary": true,
      "connected_at": "2025-10-01T12:00:00Z",
      "status": "active"
    },
    {
      "account_id": "token-uuid-2",
      "email": "personal@gmail.com",
      "is_primary": false,
      "connected_at": "2025-10-15T14:30:00Z",
      "status": "active"
    }
  ]
}
```

**Implementation:** `src/main_refactored.py:709-738`

**Notes:**
- Returns all OAuth tokens for the authenticated user
- Status values: active, expired, revoked, error
- Uses `CredentialsManager.list_connected_accounts()`

---

### 5. DELETE /api/v1/auth/accounts/{account_id}

**Purpose:** Remove a connected Google Calendar account

**Authentication:** JWT Bearer token required

**Request:**
```http
DELETE /api/v1/auth/accounts/token-uuid-2
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "message": "Account disconnected successfully",
  "account_id": "token-uuid-2"
}
```

**Error Responses:**
- `400 Bad Request`: Cannot delete the only connected account
- `404 Not Found`: Account not found
- `401 Unauthorized`: Invalid or missing JWT token

**Implementation:** `src/main_refactored.py:741-774`

**Notes:**
- Revokes OAuth tokens with Google (best effort)
- Deletes from database even if Google revocation fails
- Prevents deletion if it's the user's only account
- Uses `CredentialsManager.revoke_account()`

---

## Database Schema Changes

### OAuthToken Model Updates

**File:** `src/database/models.py:59-78`

**New Columns:**

| Column | Type | Default | Description |
|--------|------|---------|-------------|
| `account_email` | String | NULL | Email of the connected Google account |
| `status` | String | "active" | Account health status |
| `connected_at` | DateTime | utcnow() | When account was connected |
| `is_primary` | Boolean | False | Is this the primary calendar? |

**Status Values:**
- `active` - Account is working correctly
- `expired` - Access token expired, needs refresh
- `revoked` - User revoked access
- `error` - Authentication error occurred

**Migration Required:** Yes (see Migration Guide below)

---

### Pydantic Schemas Added

**File:** `src/schemas.py`

**New Models:**

```python
# Settings/Constitution
class WorkHours(BaseModel)
class ProtectedTimeBlock(BaseModel)
class SchedulingRules(BaseModel)
class Settings(BaseModel)
class SettingsUpdateRequest(BaseModel)
class SettingsUpdateResponse(BaseModel)

# Account Management
class GoogleAuthUrlResponse(BaseModel)
class ConnectedAccount(BaseModel)
class ConnectedAccountsResponse(BaseModel)
class AccountDeleteResponse(BaseModel)

# Thread Management (Optional - P2)
class Thread(BaseModel)
class CreateThreadRequest(BaseModel)
class ThreadsResponse(BaseModel)
class ThreadDeleteResponse(BaseModel)
```

---

### CredentialsManager Enhancements

**File:** `src/auth/credentials_manager.py`

**New Methods:**

```python
async def list_connected_accounts(user_id: str) -> list[OAuthToken]
    """List all connected accounts for a user."""

async def revoke_account(user_id: str, account_id: str) -> bool
    """Revoke and delete a connected account."""
```

**Implementation:** Lines 167-232

---

## Breaking Changes

### 1. Graph Initialization Now Async

**Impact:** Medium
**Affected Code:** Any code that calls `initialize_graph()`

**Before:**
```python
graph = initialize_graph(session)
result = graph.invoke(data, config=config)
```

**After:**
```python
graph = await initialize_graph(session)
result = await graph.ainvoke(data, config=config)
```

**Migration:**
- All endpoint handlers are already async (no external impact)
- If you have custom scripts that use `initialize_graph()`, add `await`

---

### 2. Checkpoints Stored on Disk

**Impact:** Low
**Affected:** Deployment environment

**Before:**
- Checkpoints stored in memory
- Lost on server restart

**After:**
- Checkpoints stored in `checkpoints.db` SQLite file
- Persists across restarts

**Migration:**
- Ensure write permissions for `checkpoints.db` in app directory
- Add `checkpoints.db` to `.gitignore`
- Consider backing up `checkpoints.db` in production

---

## Migration Guide

### Step 1: Database Migration

Since we're using SQLite with SQLAlchemy, the new columns will be added automatically on first run. However, existing OAuth tokens won't have the new fields populated.

**Option A: Automatic (Recommended for Development)**

The application will handle NULL values gracefully:
- `account_email` ‚Üí Falls back to user email
- `status` ‚Üí Defaults to "active"
- `connected_at` ‚Üí Uses current time
- `is_primary` ‚Üí Defaults to False

**Option B: Manual Update (Recommended for Production)**

```sql
-- Add default values for existing tokens
UPDATE oauth_tokens
SET
  status = 'active',
  connected_at = datetime('now'),
  is_primary = 0
WHERE status IS NULL;

-- Optional: Update account_email from user's email
UPDATE oauth_tokens
SET account_email = (
  SELECT email FROM users WHERE users.user_id = oauth_tokens.user_id
)
WHERE account_email IS NULL;

-- Set first token as primary for each user
WITH ranked_tokens AS (
  SELECT
    token_id,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at) as rn
  FROM oauth_tokens
)
UPDATE oauth_tokens
SET is_primary = 1
WHERE token_id IN (SELECT token_id FROM ranked_tokens WHERE rn = 1);
```

---

### Step 2: Update Dependencies

Ensure `langgraph` supports `AsyncSqliteSaver`:

```bash
pip install langgraph>=0.4.0
```

Check `requirements.txt` - this should already be satisfied.

---

### Step 3: Environment Setup

**Add to `.gitignore`:**
```
checkpoints.db
checkpoints.db-shm
checkpoints.db-wal
```

**Set File Permissions (Linux/Mac):**
```bash
chmod 664 checkpoints.db
```

---

### Step 4: Frontend Integration

**Update `frontend/.env`:**
```bash
# Disable mocks - use real backend endpoints
VITE_ENABLE_MOCK_API=false
VITE_API_BASE_URL=http://localhost:8000
```

**Remove Mocks (Optional):**

Edit `frontend/src/services/apiClient.ts`:
- Remove mock data constants (lines 158-180, 214-224, 275-284)
- Remove `ENABLE_MOCK` checks
- Keep only real API calls

---

## Testing Checklist

### Critical Bug Fixes

- [ ] **Test Human-in-the-Loop Workflow**
  1. Call `POST /agent/query` with: "I need to reschedule my 2pm meeting"
  2. Verify response includes `requires_approval: true`
  3. Extract `thread_id` from response
  4. Call `POST /agent/approve` with same `thread_id` and `approved: true`
  5. Verify workflow completes successfully
  6. Check `checkpoints.db` file was created

- [ ] **Test Checkpoint Persistence**
  1. Call `/agent/query` and get a checkpoint
  2. Restart the backend server
  3. Call `/agent/approve` with the same thread_id
  4. Verify it resumes from checkpoint (doesn't fail)

- [ ] **Test Concurrent Users**
  1. Create 2 users, both trigger approval workflows
  2. Verify each user's checkpoints are isolated
  3. User A cannot access User B's thread_id

---

### New Endpoints

- [ ] **Settings Endpoints**
  - [ ] GET `/api/v1/settings` returns defaults for new user
  - [ ] POST `/api/v1/settings` with partial update (work hours only)
  - [ ] GET `/api/v1/settings` again - verify changes persisted
  - [ ] Verify JWT authentication required (401 without token)

- [ ] **Account Management**
  - [ ] GET `/api/v1/auth/google/url` returns valid OAuth URL
  - [ ] Click URL, authorize, verify `/auth/callback` saves token
  - [ ] GET `/api/v1/auth/accounts` shows connected account
  - [ ] Try DELETE with only account (verify 400 error)
  - [ ] Connect second account
  - [ ] DELETE second account (verify 200 success)

---

### Regression Testing

- [ ] Existing `/agent/invoke` endpoint still works
- [ ] User creation (`POST /users`) still works
- [ ] Login (`POST /token`) still works
- [ ] OAuth callback (`GET /auth/callback`) still works

---

## Deployment Instructions

### Development

```bash
# 1. Pull latest code
git pull origin claude/clone-abp-agent-repo-011CUTMj7L4RuoUHQpUhKFNn

# 2. Install dependencies (if needed)
pip install -r requirements.txt

# 3. Run the server
python -m src.main_refactored

# 4. Test endpoints
curl -X POST http://localhost:8000/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=test@example.com&password=testpass"
```

---

### Production

**1. Backup Database**
```bash
cp abp_agent.db abp_agent.db.backup.$(date +%Y%m%d)
```

**2. Deploy Code**
```bash
git pull origin main  # After merging this branch
```

**3. Install Dependencies**
```bash
pip install -r requirements.txt --upgrade
```

**4. Run Migrations**
```bash
# The new columns will be added automatically
# Optionally run manual SQL updates (see Migration Guide)
```

**5. Restart Service**
```bash
# Systemd
sudo systemctl restart abp-agent

# Docker
docker-compose up -d --build

# PM2
pm2 restart abp-agent
```

**6. Verify Health**
```bash
curl http://localhost:8000/health
```

**7. Check Logs**
```bash
tail -f /var/log/abp-agent/app.log
```

**8. Test Critical Endpoint**
```bash
# Test the fixed /agent/query endpoint
curl -X POST http://localhost:8000/agent/query \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "<real-user-id>",
    "prompt": "How busy am I next week?"
  }'
```

---

## Rollback Plan

If issues are discovered in production:

**1. Rollback Code**
```bash
git checkout <previous-commit-hash>
git push origin main --force  # Use with caution
```

**2. Restore Database (if needed)**
```bash
cp abp_agent.db.backup.20251025 abp_agent.db
```

**3. Restart Service**
```bash
sudo systemctl restart abp-agent
```

**Known Safe Commit:** `d5f4958` (before these changes)

---

## Performance Considerations

### Checkpoint Database Growth

**Issue:** `checkpoints.db` will grow over time as checkpoints accumulate.

**Mitigation:**

1. **Auto-cleanup (Recommended):**
```python
# Add to scheduled task (run daily)
import os
import time
from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver

async def cleanup_old_checkpoints():
    """Delete checkpoints older than 7 days."""
    checkpointer = AsyncSqliteSaver.from_conn_string("checkpoints.db")
    cutoff = time.time() - (7 * 24 * 60 * 60)  # 7 days ago
    # Implement cleanup logic based on LangGraph API
```

2. **Manual cleanup:**
```bash
# Delete checkpoints.db and restart (safe if all workflows complete)
rm checkpoints.db
sudo systemctl restart abp-agent
```

---

## Support & Troubleshooting

### Common Issues

**1. `ModuleNotFoundError: langgraph.checkpoint.sqlite.aio`**

**Solution:**
```bash
pip install langgraph>=0.4.0 --upgrade
```

---

**2. `OperationalError: database is locked`**

**Cause:** Multiple processes accessing checkpoints.db

**Solution:**
- Use only one backend process
- Or use PostgreSQL checkpointer instead of SQLite

---

**3. `/agent/approve` returns "Checkpoint not found"**

**Cause:** Checkpoint expired or thread_id mismatch

**Solution:**
- Verify thread_id matches the one from `/agent/query`
- Check `checkpoints.db` file exists and has write permissions
- Verify checkpointer initialization succeeded (check logs)

---

**4. Settings endpoint returns empty constitution**

**Cause:** User has no scheduling rules in database

**Expected:** This is correct - returns default constitution

**Verify:**
```bash
sqlite3 abp_agent.db "SELECT * FROM scheduling_rules WHERE user_id = '<user-id>';"
```

---

## Contributors

- **Backend Implementation:** Claude (AI Assistant)
- **Code Review:** Required before production deployment
- **Testing:** QA Team

---

## Appendix A: API Endpoint Summary

| Method | Endpoint | Authentication | Purpose |
|--------|----------|----------------|---------|
| POST | `/agent/query` | User ID | Main agent interaction (stateful) |
| POST | `/agent/approve` | User ID | Approve/deny proposed actions |
| POST | `/agent/invoke` | JWT | Simple queries (stateless) |
| GET | `/api/v1/settings` | JWT | Get user constitution |
| POST | `/api/v1/settings` | JWT | Update constitution |
| GET | `/api/v1/auth/google/url` | JWT | Get OAuth URL |
| GET | `/api/v1/auth/accounts` | JWT | List connected accounts |
| DELETE | `/api/v1/auth/accounts/{id}` | JWT | Remove account |

---

## Appendix B: File Change Summary

| File | Lines Changed | Description |
|------|---------------|-------------|
| `src/graph/graph_refactored.py` | +24, -11 | AsyncSqliteSaver implementation |
| `src/main_refactored.py` | +289, -47 | Graph init fixes + 5 new endpoints |
| `src/schemas.py` | +92, -0 | New Pydantic models |
| `src/database/models.py` | +4, -1 | OAuthToken schema updates |
| `src/auth/credentials_manager.py` | +66, -0 | Account management methods |
| **Total** | **+475, -59** | **416 net lines added** |

---

## Version History

- **v3.1.0** (2025-10-25) - Critical bug fixes + Settings/Account endpoints
- **v3.0.1** (2025-10-24) - Bug fixes and improvements
- **v3.0.0** (2025-10-20) - Initial production-ready release

---

**End of Release Notes**
